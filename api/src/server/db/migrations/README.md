```
In development process I rely on automatic database sync provided by TypeORM.
I will add migrations when we will have first real testing environment.
```

# Database migrations

This document covers all things related to database migrations in the project. Whenever a breaking change is introduced in the database (think column alterations, enum changes, new tables) a migration should follow suit to allow smooth feature introduction in both development and production environments.

## Migration basics

In TypeORM, migrations are JS classes with two methods:

- `public async up(queryRunner: QueryRunner)` - defines what happens when migration is applied on the database

- `public async down(queryRunner: QueryRunner)` - defines what happens when migration is reverted

Both methods accept `queryRunner` which allows running SQL queries on the database. Fear not, for in most cases the functions' bodies will be generated by typeORM. This does not mean that they should not be checked by us humans - never fully trust generated code.

## Scripts

To manipulate migrations and move between database versions, we have a set of scripts to be executed. All of them should be run with use of `docker-compose run --rm api ...`.

### Reverting migrations

- `npm run typeorm migration:revert` - reverts the last migration run on project's database. Run multiple times to keep moving back in migrations.

### Applying migrations

- `npm run typeorm migration:run` - applies all remaining migrations found in `src/db/migrations`. TypeORM decides which migrations to run based on an internal table in database which stores the names of already applied migrations.

### Generating migrations

- `npm run typeorm migration:generate -- -n "NameOfMigration"` - generates a new migration with implementation of `up()` and `down()` methods based on the current state of your database and entities content in `src/db/entities`.
  - We follow a certain pattern when it comes to migration names. First of all, since a class is generated, PascalCase should be used in the name. Secondly, the name should clearly indicate the kind of change introduced by the migration, such as:
    - `Create[TableName]Table`
    - `Remove[ColumnName]From[TableName]`
    - `Add[ValueName]To[EnumName]`
  - In most cases, when building large features requiring multiple new tables or breaking changes, it is safer and easier to maintain multiple migrations as well, for example: first migration introducing new tables, second modifying existing tables accordingly etc. In an event of error, it is easier to pinpoint where exactly it happens.
  - In the perfect scenario, migrations should allow us to move freely between them with little to no loss of data stored. Sometimes this requires additional code or database operations not generated by typeORM. This is not always the case though - if you feel that some changes are to difficult to be irreversible, note and motivate it in your pull request. In such cases, backups should come to life.
- `npm run typeorm migration:create -- -n "NameOfMigration"` - creates an empty migration. Perfect for manual fixes undetectable by typeORM.

## Documentation

For more details regarding migrations, refer to the [typeORM migration docs](https://github.com/typeorm/typeorm/blob/master/docs/migrations.md).
